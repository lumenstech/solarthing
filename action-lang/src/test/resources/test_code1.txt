scope : queue {
  init myCounter : const [ 0.0 ]
  init myText : const [ "hello there" ])
  fun main : withlock("low_battery_alert", call run_check, ontimeout = log("low_battery_alert locked", debug = true))

  // Use the "exp" action to define battery_is_fine
  exp battery_is_fine : comparison(battery-voltage, ">", const [ 23.0 ])  // equivalent to the above
  act run_check : race {
    racer(all(eval battery_is_fine)) : pass
    racer(wait PT120S) : queue {
      log("Battery getting lower", summary = true)
      wait PT30M
    }
  }

  act sin : import("./myMathSin.al")  // myMathSin.al file is only the sin function
  select(["cos", "tan"]) : import("./myMath.al")  // myMath.al is a scope with many functions.
  // Select will run the scope and then populate the current scope with "cos" and "tan".
  act some_random_function : parallel {
    // parenthesis are not necessary when only a single argument is provided
    queue { wait PT5S ; print "5 seconds is up" }
    queue { wait PT10S ; print("10 seconds is up") }
    queue {
      set myCounter : binary(get myCounter, "+", const 1)
      print(concat(get myText, " how is it going?"))
      scope : queue {
        // p_ is a convention for variable names that are effectively arguments to a function
        // In this case, draw_line is essentially a function that does something with two parameters, x and y
        init(p_x, [ 0 ])
        init(p_y, [ 0 ])
        call draw_line
      }
    }
  }

  call main
}
